using PyPlot

function earthquake_exercise_setup(value_for_two, filename)
    # explosion detector (using spiral coordinate system)
    # define the coordinate system:
    S=2000 # number of points on the spiral
    rate=25 # angular rate of spiral
    sd=0.2 # standard deviation of the sensor Gaussian noise

    x=zeros(S); y=zeros(S)
    for s=1:S
        theta=rate*2*pi*s/S;  r=s/S
        x[s]=r*cos(theta); y[s]=r*sin(theta)
    end

    # define the locations of the detection stations on the surface
    # Also define what value on each sensor would be generated by an explostion at internal location s
    N=30 # number of stations
    x_sensor=zeros(N); y_sensor=zeros(N)
    v=zeros(S,S,N)
    for sensor=1:N
        theta_sensor=2*pi*sensor/N
        x_sensor[sensor]=cos(theta_sensor); y_sensor[sensor]=sin(theta_sensor)
        for s=1:S
            for t=1:S
                v[s,t,sensor]=value_for_two(x[s],y[s],x[t],y[t],x_sensor[sensor],y_sensor[sensor]) # explosion value for some value function
            end
        end
    end

    v_one=zeros(S,N)
    for sensor=1:N
        for s=1:S
            v_one[s,sensor]=value_for_one(x[s],y[s],x_sensor[sensor],y_sensor[sensor]) # explosion value for some value function
        end
    end

    value_file = open(filename)
    val = map(x->parse(Float64, x), readlines(value_file))

    logp=zeros(S,S)
    for s=1:S
        for t=1:S
            for sensor=1:N
                logp[s,t] += -0.5*(val[sensor]-v[s,t,sensor])^2/(sd^2) # Gaussian distribution
            end
        end
    end

    logp_one=zeros(S)
    for s=1:S
        for sensor=1:N
            logp_one[s] += -0.5*(val[sensor]-v_one[s,sensor])^2/(sd^2) # Gaussian distribution
        end
    end

    p_temp=exp.(logp .- maximum(logp)) .* (1/sqrt(2*3.14*sd^2))

    p_temp_one=exp.(logp_one .- maximum(logp_one)) .* (1/sqrt(2*3.14*sd^2))

    p_H2 = 0
    for s=1:S
        for t=1:S
            p_H2 += p_temp[t,s] * (1/S) * (1/S)
        end
    end

    p_H1 = 0
    for s=1:S
        p_H1 += p_temp_one[s] * (1/S)
    end

    # println("H1: $p_H1 H2: $p_H2")
    println("For $filename logp(v|H2) - logp(v|H1) = $(log(p_H2) - log(p_H1))")

    p=zeros(S)
    for s=1:S
        for t=1:S
            p[s] += p_temp[s,t]
        end
    end
    maxp,maxind =findmax(p)
    figure()
    for s=1:S
        plot(x[s],y[s],".",color=(1-(p[s]/maxp))*[1,1,1])
    end
    for theta=0:0.01:2*pi
    plot(cos(theta),sin(theta),".",color=[0,0,0])
    end
        sf=0.2
    for sensor=1:N
        plot(x_sensor[sensor],y_sensor[sensor],"o",color=[1,0,0])
        theta_sensor=2*pi*sensor/N
        x_sensor_nm=(1+sf*val[sensor])*cos(theta_sensor+0.05)
        y_sensor_nm=(1+sf*val[sensor])*sin(theta_sensor+0.05)
        plot([x_sensor[sensor], x_sensor_nm],[y_sensor[sensor], y_sensor_nm],"-m")
    end
    plot(x[maxind],y[maxind],"m+",markersize=20,label="estimated (most likely)")
    legend()
end

function value_for_two_sum(x1, y1, x2, y2, x_sensor, y_sensor)
    (1 / ((x1 - x_sensor)^2 + (y1 - y_sensor)^2 + 0.1)) + (1 / ((x2 - x_sensor)^2 + (y2 - y_sensor)^2 + 0.1))
end

function value_for_two_mean(x1, y1, x2, y2, x_sensor, y_sensor)
    (0.5 / ((x1 - x_sensor)^2 + (y1 - y_sensor)^2 + 0.1)) + (0.5 / ((x2 - x_sensor)^2 + (y2 - y_sensor)^2 + 0.1))
end

function value_for_one(x1, y1, x_sensor, y_sensor)
    (1 / ((x1 - x_sensor)^2 + (y1 - y_sensor)^2 + 0.1))
end

earthquake_exercise_setup(value_for_two_mean, "EarthquakeExerciseMeanData.txt")
earthquake_exercise_setup(value_for_two_sum, "EarthquakeExerciseData.txt")
