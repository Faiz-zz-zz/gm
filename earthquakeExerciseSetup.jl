using PyPlot
function earthquake_exercise_setup()
    # explosion detector (using spiral coordinate system)
    # define the coordinate system:
    S=2000 # number of points on the spiral
    rate=25 # angular rate of spiral
    sd=0.2 # standard deviation of the sensor Gaussian noise

    x=zeros(S); y=zeros(S)
    for s=1:S
        theta=rate*2*pi*s/S;  r=s/S
        x[s]=r*cos(theta); y[s]=r*sin(theta)
    end

    # define the locations of the detection stations on the surface
    # Also define what value on each sensor would be generated by an explostion at internal location s
    N=30 # number of stations
    x_sensor=zeros(N); y_sensor=zeros(N)
    v=zeros(S,S,N)
    for sensor=1:N
        theta_sensor=2*pi*sensor/N
        x_sensor[sensor]=cos(theta_sensor); y_sensor[sensor]=sin(theta_sensor)
        for s=1:S
            for t=1:S
                v[s,t,sensor]=value(x[s],y[s],x[t],y[t],x_sensor[sensor],y_sensor[sensor]) # explosion value for some value function
            end
        end
    end
    value_file = open("EarthquakeExerciseData.txt")
    val = map(x->parse(Float64, x), readlines(value_file))

    logp=zeros(S,S)
    for s=1:S
        for t=1:S
            for sensor=1:N
                logp[s,t] += -0.5*(val[sensor]-v[s,t,sensor])^2/(sd^2) # Gaussian distribution
            end
        end
    end
    p_temp=exp.(logp - maximum(logp)) * (1/sqrt(2*3.14*sd^2))
    p_temp/=sum(p_temp)

    p_H1 = 0
    for s=1:S 
        p_H1 += p_temp[s,s] 
    end

    p_H2 = 0
    for s=1:S 
        for t=1:S 
            if s != t
                p_H2 += p_temp[s,t] 
            end
        end
    end

    println("logp(v|H2) - logp(v|H1) = $(log(p_H2) - log(p_H1))")

    p=zeros(S)
    for s=1:S 
        for t=1:S 
            p[s] += p_temp[s,t]
        end
    end
    maxp,maxind =findmax(p)
    figure()
    for s=1:S
        plot(x[s],y[s],".",color=(1-(p[s]/maxp))*[1,1,1])
    end
    for theta=0:0.01:2*pi
    plot(cos(theta),sin(theta),".",color=[0,0,0])
    end
        sf=0.2
    for sensor=1:N
        plot(x_sensor[sensor],y_sensor[sensor],"o",color=[1,0,0])
        theta_sensor=2*pi*sensor/N
        x_sensor_nm=(1+sf*val[sensor])*cos(theta_sensor+0.05)
        y_sensor_nm=(1+sf*val[sensor])*sin(theta_sensor+0.05)
        plot([x_sensor[sensor], x_sensor_nm],[y_sensor[sensor], y_sensor_nm],"-m")
    end
    plot(x[maxind],y[maxind],"m+",markersize=20,label="estimated (most likely)")
    legend()
end

function value(x1, y1, x2, y2, x_sensor, y_sensor) 
    (1 / ((x1 - x_sensor)^2 + (y1 - y_sensor)^2 + 0.1)) + (1 / ((x2 - x_sensor)^2 + (y2 - y_sensor)^2 + 0.1))
end
